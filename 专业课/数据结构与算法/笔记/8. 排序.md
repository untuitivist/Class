
[排序可视化 - VisuAlgo](https://visualgo.net/zh/sorting)

## 1. 基本概念

+ 排序: 重新排列表中的元素, 使表中的元素满足按关键字有序
+ 稳定性: 所有元素相对位置不变即为稳定
+ 内部排序: 指在排序期间元素全部存在内存中的排序, 排序的过程中根据要求不断地比较和移动
    + 插入排序、交换排序、选择排序、归并排序和基数排序
+ 外部排序: 指在排序期间元素无法全部同时存放在内存中, 必须在排序的过程中根据要求不断地在内, 外存之间移动的排序

## 2. 插入排序

### 2.1 直接插入排序*

基本思想: 每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中, 直到全部记录插入完成
```python
def InsertSort(Sqlist: list) -> list:
    for i in range(1, len(Sqlist)):
        if Sqlist[i]< Sqlist[i - 1]:
            val = Sqlist[i]
            for j in range(i-1, -1, -1):
                if val < Sqlist[j]:
                    Sqlist[j+1] = Sqlist[j]
                else:
                    Sqlist[j+1] = val
                    break
            else:
                Sqlist[0] = val
    return Sqlist
```


|  |  |
| - | - |
| 空间复杂度 | $O(1)$ |
| 时间复杂度 | $O(n^2)$ |
| 稳定性 | 稳定 |

### 2.2 折半插入排序

在直接插入排序的基础上, 使用[[7. 查找#3. 二分查找|折半查找]]的思想寻找插入点


|  |  |
| - | - |
| 空间复杂度 | $O(1)$ |
| 时间复杂度 | $O(n^2)$ |
| 稳定性 | 稳定 |

### 3.3 希尔排序

把相隔某个增量的记录组成一个子表, 对各个子表分别进行直接插入排序, 当整个表中的元素已呈基本有序时, 再对全体记录进行一次直接插入排序

|  |  |
| - | - |
| 空间复杂度 | $O(1)$ |
| 时间复杂度 |  |
| 稳定性 | 不稳定 |

## 3. 交换排序

### 3.1 冒泡排序

基本思想: 从后往前 (或者从前往后)两两比较相邻元素的值, 若为逆序则进行交换, 直到序列比较完, 第一趟冒泡结束, 结果是将最小的元素交换到待排序列的第一个位置(或将最大的元素交换到待排序列的最后一个位置)

```python
def BubbSort(Sqlist: list) -> list:
    for i in range(len(Sqlist)):
        for j in range(len(Sqlist), i, -1):
            j -= 1
            if Sqlist[j] < Sqlist[j-1]:
                Sqlist[j], Sqlist[j-1] = Sqlist[j-1], Sqlist[j]
    return Sqlist
```

|  |  |
| - | - |
| 空间复杂度 | $O(1)$ |
| 时间复杂度 | $O(n^2)$ |
| 稳定性 | 稳定 |


### 3.2 快速排序*

基本思想是: 在待排序表$L[1\cdots n]$中任取一个元素$pivot$作为枢轴(通常取首元素),  通过一趟快速排序将待排序表划分为独立的两部分 $L[1\cdots k-1]$和$L[k+1\cdots n]$, $pivot$放在了最终位置$L[k]$中


快速排序是所有内部排序算法中平均性能最优的排序算法
快速排序并不适用于原本有序或基本有序的记录序列进行排序


## 4. 选择排序

### 4.1 简单选择排序

基本思想: 假设排序表为$L[1\cdots n]$, 第$i$趟排序即从$L[1\cdots n]$中选择关键字最小的元素与$L[i]$交换

```python
def SSSort(Sqlist: list) -> list:
    for i in range(len(Sqlist)-1):
        min = i+1
        for j in range(i, len(Sqlist)):
            if Sqlist[j] < Sqlist[min]:
                min = j
        Sqlist[i], Sqlist[min] = Sqlist[min], Sqlist[i]
        print(f'{i+1}\t{Sqlist}')
    return Sqlist
```

|  |  |
| - | - |
| 空间复杂度 | $O(1)$ |
| 时间复杂度 | $O(n^2)$ |
| 稳定性 | 不稳定 |

### 4.2 堆排序

#### 堆

+ 小根堆: 二叉树与其子树的根小于孩子
+ 大根堆: 二叉树与其子树的根大于孩子

#### 排序

共$n$个结点, 从层序遍历第$\lfloor\frac{n}{2}\rfloor$个结点开始前数, 以选中的结点为子树根结点制造大/小根堆
![[Pasted image 20231212232818.png]]

#### 删除

输出栈顶元素后, 将堆的最后一个元素与栈顶元素交换, 此时堆的性质被破坏, 重新制造大/小根堆

#### 插入

对堆进行插入操作时, 先将新结点放在堆的末端, 再对这个新结点向上执行调整操作

|  |  |
| - | - |
| 空间复杂度 | $O(1)$ |
| 时间复杂度 | $O(n\log_2{n})$ |
| 稳定性 | 不稳定 |

## 5. (二路)归并排序

“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表
![[Pasted image 20231212233636.png]]

|  |  |
| - | - |
| 空间复杂度 | $O(1)$ |
| 时间复杂度 | $O(n\log_2{n})$ |
| 稳定性 | 稳定 |

## 6. 基数排序

基数排序不基于比较和移动进行排序, 而基于关键字各位的大小排序

|  |  |
| - | - |
| 空间复杂度 | $O(r)$ |
| 时间复杂度 | $O(d(n+r))$ |
| 稳定性 | 稳定 |

## 7. 各种排序算法的比较



| 算法种类 | 时间复杂度最好情况 | 时间复杂度平均情况 | 时间复杂度最坏情况 | 空间复杂度 | 是否稳定 |
|:-:|:-:|:-:|:-:|:-:|:-:|
|直接插入排序|$O(n)$|$O(n^2)$|$O(n^2)$|$O(1)$|是|
|希尔排序||||$O(1)$|否|
|冒泡排序|$O(n)$|$O(n^2)$|$O(n^2)$|$O(1)$|是|
|快速排序|$O(n\log_2{n})$|$O(n\log_2{n})$|$O(n^2)$|$O(\log_2{n})$|是|
|简单选择排序|$O(n^2)$|$O(n^2)$|$O(n^2)$|$O(1)$|否|
|堆排序|$O(n\log_2{n})$|$O(n\log_2{n})$|$O(n\log_2{n})$|$O(1)$|否|
|二路归并排序|$O(n\log_2{n})$|$O(n\log_2{n})$|$O(n\log_2{n})$|$O(n)$|是|
|基数排序|$O(d(n +r))$|$O(d(n +r))$|$O(d(n +r))$|$O(r)$|是|








