
## 1. 栈 Stack

### 1.1 栈的基本概念

+ 栈: 只允许在一端进行插入或删除操作的线性表
    + 栈顶
    + 栈底
+ 空栈: 不含任何元素的空表
+ 特性: **先进后出**
+ **$n$个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C^n_{2n}$**
+ 栈能适用于**递归算法, 表达式求值以及括号匹配等问题**

### 1.2 栈的基本操作:

|  |  |
|:- |:- |
| $InitStack(\&S)$ | 初始化一个空栈 |
| $StackEmpty(S)$ | 判断一个栈是否为空 |
| $Push(\&S, x)$ | 进栈 |
| $Pop(\&S, \&x)$ | 出栈 |
| $GetTop(S, \&x)$ | 读栈顶元素 |
| $DestroyStack(\&S)$ | 销毁栈, 并释放栈S占用的存储空间 |

### 1.3 共享栈

见*MainCode/Class/数据结构与算法/实验/Stack/双头栈.py*
![[Pasted image 20231209212454.png]]

### 1.4 链栈

![[Pasted image 20231209212938.png]]
链栈的优点是便于多个栈共享存储空间和提高其效率, 且不存在栈满上溢的情况

## 2. 队列 Queue

### 2.1 队列的基本概念


+ 队列: 只允许在表的一端进行插入，而在表的另一端进行删除
    + 队头指针$front$指向队头元素
    + 队尾指针$rear$指向队尾元素的下一个位置
    + 入队或进队
    + 出队或离队
+ 特性: 先进先出

### 2.2 队列的基本操作

|  |  |
| :-  | :- |
| $InitQueue(\&Q)$ | 初始化队列 |
| $QueueEmpty(Q)$ | 判队列空 |
| $EnOueue(\&Q,x)$ | 入队 |
| $DeQueue(\&Q,\&x)$ | 出队 |
| $GetHead(Q,\&x)$ | 读队头元素 |

### 2.3 顺序队列

![[Pasted image 20231209215524.png]]

+ 初始状态: $Q.front = Q.rear = 0$
+ 判空条件: $Q.front == Q.rear ==0$
+ 判满条件$Q.rear == MaxSize ?$:
    + 若无出队, 队列为满
    + 若有出队, 出队几个元素, 队空几个, "假溢出"
+ 进队操作: 队不满时, 先送值到队尾元素, 再将队尾指针进1
+ 出队操作: 队不空时, 先取队头元素值, 再将队头指针进1

### 2.4 循环队列

+ 为了克服"假溢出"时需要移动大量元素
+ 把存储队列元素的表从逻辑上视为一个环, 如图:![[Pasted image 20231209215419.png]]
+ 初始时: $Q.front = Qrear = 0$
+ 进队操作: 队不满时, 先送值到队尾元素, 再将队尾指针进1
    + $Q.rear =(Q.rear +1)\%MaxSize$
+ 出队操作: 队不空时, 先取队头元素值, 再将队头指针进1
    + $Q.front =(Q.front + 1)\%MaxSize$
+ 队列长度: $(Q.rear - Q.front + MaxSize)\%MaxSize$
![[Pasted image 20231210141533.png]]
+ 队空条件: $Q.front==Q.rear$
+ 队满条件: $(Q.rear +1)\%MaxSize == Q.front$ 牺牲一个单元来区分队空和队满，入队时少用一个队列单元 

### 2.5 链队
![[Pasted image 20231210143515.png]]












