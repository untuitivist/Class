

## 题

有如下C语言程序
```C
#include<stdio.h>

int main()
{
       float x=90000.2f;
       float y=0.4f;
       x=x+y;
       printf(“%f”,x);
       return 0;
}
```

以上程序编译运行后的输出结果是90000.601562，请阐述（**看清楚不是简答）**产生以上输出的原因。
若将以上程序中的float改为double，结果是多少？为什么？

## 解

### 1. 简介

通过分析上述C语言程序，解释其输出结果，并探讨将`float`改为`double`后结果不同的原因。这涉及浮点数表示和运算中的精度和舍入误差。


### 2. 浮点数表示

#### 2.1 `float`类型的表示

`float`是单精度浮点数，使用32位（4字节）存储。IEEE 754标准格式包括：
- 1位符号位
- 8位指数位
- 23位尾数位（有效数字）

#### 2.2 `double`类型的表示

`double`是双精度浮点数，使用64位（8字节）存储。IEEE 754标准格式包括：
- 1位符号位
- 11位指数位
- 52位尾数位（有效数字）

### 3. `float`运算中的误差分析

#### 3.1 90000.2f的表示

- `90000.2`在二进制中的表示近似为：`10101111110010000.00110011001100110011`（无限小数，被截断）
- IEEE 754单精度浮点数表示为：
  - 符号位：0
  - 指数位：`10001111`（即 `16`，偏移量为 `127`）
  - 尾数位：`01011111100100000011001`（近似值）

在32位内存中的表示为：`01000111101011111100100000011001`。
转换为十进制为: `90000.203125`
#### 3.2 0.4f的表示

- `0.4`在二进制中的表示近似为：`0.01100110011001100110011`（无限小数，被截断）
- IEEE 754单精度浮点数表示为：
  - 符号位：0
  - 指数位：`01111101`（即 `-2`，偏移量为 `127`）
  - 尾数位：`10011001100110011001101`（近似值）

在32位内存中的表示为：`00111110110011001100110011001101`。
转换为十进制为: `0.4000000059604644775390625`

#### 3.3 加法运算中的误差

- 将`90000.2f`和`0.4f`相加时，先对齐指数，然后执行加法运算。
- 由于浮点数的尾数位有限，运算结果会产生舍入误差。

结果存储在`float`类型中，尾数位精度为23位，导致`90000.2f + 0.4f`的结果近似为`90000.6015625`。

### 4. `double`运算中的误差分析

将程序修改为`double`类型如下：

```c
#include <stdio.h>

int main() {
    double x = 90000.2;
    double y = 0.4;
    x = x + y;
    printf("%lf", x);
    return 0;
}
```

#### 4.1 90000.2的表示

- `90000.2`在双精度浮点数中的表示近似为：`10101111110010000.0011001100110011001100110011001100110011001100110011`（更高精度）

在64位内存中的表示为：`0100000011110101111110010000001100110011001100110011001100110011`。
转换为十进制为: `90000.199999999997089616954326629638671875`

#### 4.2 0.4的表示

- `0.4`在双精度浮点数中的表示近似为：`0.011001100110011001100110011001100110011001100110011001100110011`（更高精度）

在64位内存中的表示为：`0011111111011001100110011001100110011001100110011001100110011010`。
转换为十进制为: `0.40000000000000002220446049250313080847263336181640625`
#### 4.3 加法运算中的误差

- 双精度浮点数有52位尾数位，能更精确地表示和运算。
- 由于精度提高，`90000.2 + 0.4`的结果更接近实际值。

结果存储在`double`类型中，尾数位精度为52位，导致`90000.2 + 0.4`的结果近似为`90000.603125`.

### 5. 总结

- **单精度浮点数**：由于尾数位有23位，表示精度有限，导致舍入误差，使得`90000.2f + 0.4f`结果为`90000.6015625`。
- **双精度浮点数**：由于尾数位有52位，表示精度更高，舍入误差更小，使得`90000.2 + 0.4`结果为`90000.600000`。

浮点数运算中的舍入误差是由于其有限的表示精度造成的。

